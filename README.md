# Gozon Online Store - Microservices Architecture

Микросервисная система для обработки заказов и платежей интернет-магазина. Проект реализует асинхронную обработку транзакций с гарантиями доставки сообщений и согласованности данных.

## Описание проекта

Система состоит из двух основных микросервисов (**Orders Service** и **Payments Service**), объединенных через **API Gateway**. Взаимодействие между сервисами происходит асинхронно через брокер сообщений **RabbitMQ**.

Ключевая особенность — реализация паттерна **Saga** (Orchestration-based) для распределенных транзакций с использованием паттернов **Transactional Outbox** и **Idempotent Consumer** для обеспечения надежности (Exactly-Once delivery semantics для платежей).

## Технологический стек

* **Язык разработки:** C++ (Standard 17/20)
* **Веб-фреймворк:** Crow (C++ Microframework for Web)
* **База данных:** PostgreSQL 15 (библиотека `libpqxx`)
* **Брокер сообщений:** RabbitMQ (библиотека `SimpleAmqpClient`)
* **API Gateway / Web Server:** Nginx (Alpine)
* **Контейнеризация:** Docker, Docker Compose
* **Frontend:** HTML5, JavaScript (Fetch API), Bootstrap 5

## Архитектура

Система построена на четырех контейнерах:

1. **api-gateway (Nginx):** Единая точка входа. Проксирует запросы к микросервисам и раздает статический фронтенд. Порт: `8000`.
2. **orders-service:** Управляет жизненным циклом заказов. Реализует Transactional Outbox для отправки событий создания заказа.
3. **payments-service:** Управляет счетами пользователей. Реализует идемпотентное списание средств и Transactional Inbox/Outbox.
4. **rabbitmq:** Обеспечивает транспорт сообщений между сервисами.

## Инструкция по запуску

Для запуска требуется установленный Docker и Docker Compose.

1. **Сборка и запуск системы:**
Выполните команду в корне проекта:
```bash
docker-compose up -d --build

```

2. **Остановка системы:**
Для остановки с удалением контейнеров выполните:
```bash
docker-compose down

```


Для полной очистки базы данных добавьте флаг `-v`:
```bash
docker-compose down -v

```



## Использование

### Веб-интерфейс (Frontend)

После запуска системы откройте в браузере:
**http://localhost:8000**

Интерфейс позволяет:

* Авторизоваться под любым User ID.
* Создавать счет и пополнять баланс.
* Создавать заказы.
* Наблюдать за асинхронным обновлением статуса заказа (NEW -> FINISHED/CANCELLED) в реальном времени.

### REST API

Все запросы выполняются через Gateway на порт `8000`.

#### Payments Service

* **Создать счет**
* `POST /api/payments/create_account?user_id={id}`
* Создает счет с балансом 0.


* **Пополнить баланс**
* `POST /api/payments/add_funds?user_id={id}&amount={sum}`
* Валидация: сумма должна быть положительной.


* **Получить баланс**
* `GET /api/payments/balance?user_id={id}`



#### Orders Service

* **Создать заказ (Асинхронно)**
* `POST /api/orders/create_order?user_id={id}&amount={sum}`
* Возвращает `201 Created` и `status: NEW`. Запускает процесс списания средств в фоне.


* **Получить статус заказа**
* `GET /api/orders/order?id={order_id}`
* Возвращает текущий статус (`NEW`, `FINISHED`, `CANCELLED`).


* **Список заказов пользователя**
* `GET /api/orders/orders?user_id={id}`



## Технические особенности реализации

Для обеспечения требований надежности (Reliability) и согласованности (Consistency) реализованы следующие механизмы:

1. **Transactional Outbox Pattern:**
События не отправляются в RabbitMQ напрямую в момент HTTP-запроса. Вместо этого они сохраняются в таблицу `outbox` в рамках одной транзакции с бизнес-данными (заказом). Фоновый поток затем надежно доставляет их в брокер.
2. **Transactional Inbox / Idempotency:**
Сервис платежей проверяет таблицу `processed_orders` перед списанием средств. Это гарантирует, что даже при дублировании сообщения от брокера деньги будут списаны ровно один раз.
3. **Атомарность операций:**
Изменение баланса происходит с использованием блокировок базы данных (`SELECT ... FOR UPDATE`) или атомарных SQL-запросов, исключая состояние гонки (Race Condition).
4. **Self-Healing (Отказоустойчивость):**
Микросервисы содержат механизм автоматического восстановления соединения с RabbitMQ. При разрыве связи потоки-потребители (Consumers) и отправители (Publishers) перезапускают подключение без падения самого сервиса.
5. **Валидация:**
Реализована защита от ввода отрицательных сумм при пополнении и создании заказа.

## Структура проекта

* `/orders-service` - Исходный код сервиса заказов (C++, Dockerfile).
* `/payments-service` - Исходный код сервиса платежей (C++, Dockerfile, SQL скрипты).
* `/gateway` - Конфигурация Nginx.
* `/frontend` - Статические файлы веб-интерфейса.
* `docker-compose.yml` - Оркестрация контейнеров.
* `online_store.postman_collection.json` - Коллекция запросов для Postman.
